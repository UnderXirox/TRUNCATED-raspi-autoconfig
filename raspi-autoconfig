#! /usr/bin/env python3

# raspi-autoconfig 1.0
#
# Automatic (non-interactive) config tool for Raspbian on Raspberry Pi(R) ARM computer. 
# 
# Project homepage: http://github.com/shamiao/raspi-autoconfig
# View README.md file for help. 
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

############################################################
############  G L O B A L   V A R I A B L E S  #############
############################################################

import sys # Import globally: for stderr output

# Regex validation rules for configuration file
RPAC_CONFIG_REGEX = {
    'Screen': {
        'Resolution': '^((1,\\s+\\d+)|(2,\\s+\\d+))$', # unsafe match
        'Output': '^(Auto|HDMI|Comp)$'
    }, 
    'Wired': {
        'DHCP': '^(1|0)$',
        'IP': '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', # unsafe match
        'Subnet': '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', # unsafe match
        'Gateway': '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$' # unsafe match
    }, 
    'Wireless': {
        'SSID': '',
        'Passphrase': '',
        'DHCP': '^(1|0)$',
        'IP': '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', # unsafe match
        'Subnet': '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', # unsafe match
        'Gateway': '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$' # unsafe match
    }, 
    'Locale': {
        'Locale': '', # unsafe match
        'DefaultLocale': '', # unsafe match
        'KeyboardModel': '', # unsafe match
        'KeyboardLayout': '', # unsafe match
        'Timezone': '' # unsafe match
    },
    'APT': {
        'Mirror': '^(https|http|ftp)://[0-9a-zA-Z$\\-_.+!*\'(),/%]+$' # RFC1738. rough match
    }, 
    'Remote': {
        'SSH': '^(1|0)$',
        'VNC': '^(1|0)$',
        'VNCPassword': '',
        'VNCResolution': '^((\\d+)x(\\d+))$'
    }, 
    'SimpChinese': {
        'WQYFont': '^(1|0)$',
        'SCIMPinyin': '^(1|0)$',
        'SCIMWubi': '^(1|0)$'
    }
}

############################################################
########## A U X I L I A R Y   F U N C T I O N S  ##########
############################################################

# System requirements check
def envreq():
    # Python 3.1 required
    if sys.hexversion < 0x03010000:
        sys.stderr.write('Python 3.1 or later version required. ' + 
            '(Current version: ' + platform.python_version() + ') \n')
        return False
    
    # OS, architecture and distribution check. Require:
    # * Linux operating system
    # * armv6l hardware architecture
    # * Debian 7.0 "wheezy" distribution
    import platform
    if platform.system() != 'Linux':
        sys.stderr.write('This program must be run under Linux. \n')
        return False
    if not platform.machine().startswith('armv6'):
        sys.stderr.write('This program must be run under an ARMv6 architecture machine. \n')
        return False
    [linux_dist, linux_ver, linux_id] = platform.linux_distribution()
    if linux_dist.lower() != 'debian' or not linux_ver.startswith('7'):
        sys.stderr.write('This program must be run under Debian GNU/Linux 7.0/wheezy. \n')
        return False
    
    # Root required
    import os
    if not os.geteuid() == 0:
        sys.stderr.write('This program must be run as root. \n')
        return False
    
    # All requirements OK
    return True
# end of envreq()

# Config file load
def loadconfig(filename='/boot/autoconfig.ini'):
    import configparser;
    configfile = configparser.ConfigParser()
    readret = configfile.read(filename)
    if len(readret) == 0:
        sys.stderr.write('Unable to load configuration file \"' + filename + '\". \n')
        return False
    return configfile
# end of loadconfig()

# Find one network card, from a list of ethernet cards like:
#  [('eth0', 'b8:27:eb:00:00:00'), ('eth1', 'aa:bb:cc:dd:ee:ff')]
# Sequence:
#  (1) MAC address starts with B8:27:EB.
#  (2) eth0. 
#  (3) If none of above matches, first one. 
def choose_eth(ethslist):
    if not ethslist: return # no return value for []. 
    # (1) MAC address. 
    for eth in ethslist: 
        if eth[1].lower().startswith('b8:27:eb'):
            return eth
    # (2) eth0. 
    for eth in ethslist: 
        if eth[0].lower() ==  'eth0':
            return eth
    # (3) first one.
    return ethslist[0]
# end of choose_eth()

############################################################
############# C O N F I G   F U N C T I O N S  #############
############################################################

def setup_screen(configfile):
    SECNAME = 'Screen'
    # Run only if proper section exists in autoconfig.ini
    if not configfile.has_section(SECNAME): return False
    
    # Load config.txt
    try:
        fcnftxt = open('/boot/config.txt', 'r')
        cnftxt = fcnftxt.read()
        fcnftxt.close()
    except IOError:
        cnftxt = ''
    except:
        sys.stderr.write('FAILED: Unable to read or create /boot/config.txt! \n')
        sys.stderr.write('FAILED: All screen settings unchanged. \n')
        return False
    # Regex lib needed for editing config.txt
    import re
    
    # [Screen].Resolution
    if configfile.has_option(SECNAME, 'Resolution'):
        value = configfile.get(SECNAME, 'Resolution')
        if value.lower() == 'auto':
            # Comments out "hdmi_ignore_edid", "hdmi_group" & "hdmi_mode"
            patt = '^(hdmi_ignore_edid)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
            patt = '^(hdmi_group)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
            patt = '^(hdmi_mode)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
        else:
            m = re.match('^(?P<hdmigroup>1|2),\\s*(?P<hdmimode>\\d+)$', value)
            if m: # Parsable input (not strictly verified)
                hdmigroup = int(m.group('hdmigroup'))
                hdmimode = int(m.group('hdmimode'))
                # hdmi_mode=1~59 for hdmigroup=1, 1~86 for hdmigroup=2
                if (hdmigroup==1 and hdmimode>=1 and hdmimode<=59) or \
                    (hdmigroup==2 and hdmimode>=1 and hdmimode<=86):
                    # Set hdmi_group=<var:hdmigroup>
                    patt = '^.*hdmi_group.*$'
                    repl = 'hdmi_group=' + str(hdmigroup)
                    [cnftxt, n] = re.subn(patt, repl, cnftxt, 1, flags=re.M)
                    # Set hdmi_mode=<var:hdmimode>
                    if n == 0: cnftxt += '\n' + repl
                    patt = '^.*hdmi_mode.*$'
                    repl = 'hdmi_mode=' + str(hdmimode)
                    [cnftxt, n] = re.subn(patt, repl, cnftxt, 1, flags=re.M)
                    if n == 0: cnftxt += '\n' + repl
                    # Set hdmi_ignore_edid=0xa5000080
                    patt = '^.*hdmi_ignore_edid.*$'
                    repl = 'hdmi_ignore_edid=0xa5000080'
                    [cnftxt, n] = re.subn(patt, repl, cnftxt,, 1 flags=re.M)
                    if n == 0: cnftxt += '\n' + repl
                else: # hdmi_mode value out of range
                    sys.stderr.write('WARN: HDMI_Mode value specified in [Screen].Output out of range. \n')
                    sys.stderr.write('FAILED: Resolution unchanged. \n')
                    pass
            else: # Any other invalid value
                sys.stderr.write('WARN: Invalid [Screen].Resolution value. \n')
                sys.stderr.write('FAILED: Resolution unchanged. \n')
                pass
    # end of [Screen].Resolution
    
    # [Screen].Output
    if configfile.has_option(SECNAME, 'Output'):
        value = configfile.get(SECNAME, 'Output')
        if value.lower() == 'auto':
            # Comment out "hdmi_force_hotplug" & "hdmi_ignore_hotplug"
            patt = '^(hdmi_force_hotplug)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
            patt = '^(hdmi_ignore_hotplug)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
        elif value.lower() == 'hdmi':
            # Set "hdmi_force_hotplug=1", comment out "hdmi_ignore_hotplug"
            patt = '^.*hdmi_force_hotplug.*$'
            repl = 'hdmi_force_hotplug=1'
            cnftxt = re.sub(patt, repl, cnftxt, 1, flags=re.M)
            patt = '^(hdmi_ignore_hotplug)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
        elif value.lower() == 'comp':
            # Comment out "hdmi_force_hotplug", set "hdmi_ignore_hotplug=1"
            patt = '^(hdmi_force_hotplug)'; repl = '#\g<0>'
            cnftxt = re.sub(patt, repl, cnftxt, flags=re.M)
            patt = '^.*hdmi_ignore_hotplug.*$'
            repl = 'hdmi_ignore_hotplug=1'
            cnftxt = re.sub(patt, repl, cnftxt, 1, flags=re.M)
        else: # Any other invalid value
            sys.stderr.write('WARN: Invalid [Screen].Output value. \n')
            sys.stderr.write('FAILED: Output device unchanged. \n')
            pass
    # end of[Screen].Output
    
    # Write back config.txt
    fcnftxt = open('/boot/config.txt', 'w')
    fcnftxt.write(cnftxt)
    fcnftxt.close()
    
    return True
# end of setup_screen()

def setup_wired(configfile):
    SECNAME = 'Wired'
    # Run only if proper section exists in autoconfig.ini
    if not configfile.has_section(SECNAME): return False
    
    # Show all wired ethernet network cards (eth*)
    # Fetch `ip link show` command stdout
    import subprocess
    ipoutput = subprocess.check_output(['ip', 'link', 'show'],
        universal_newlines=True)
    # Find device name (eth*) and mac address from output
    import re
    patt = '^\d+:\s(?P<dev>eth\d+).*\n' + \
        '\s*link/ether\s+(?P<hwaddr>(?:[0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2})'
    eths = re.findall(patt, ipoutput, flags=re.M) 
    # eg: [('eth0', 'b8:27:eb:00:00:00'), ('eth1', 'aa:bb:cc:dd:ee:ff')]
    # Note: MAC Address prefix B8-27-EB = Raspberry Pi Foundation. 
    
    # Count NIC, get device name and MAC address. 
    if len(eths) == 1: 
        # One NIC (most probably Model B integrated one), use it directly.
        (ethdev, ethmac) = eth[0]
    elif len(eths) > 1:
        # Multi NIC
        sys.stderr.write('WARN: ' + str(len(eths)) + \
            ' ethernet devices (eth*) found. \n')
        (ethdev, ethmac) = choose_eth(eths)
        sys.stderr.write('INFO: Configuring ' + ethdev + \
            ' (' + ethmac + '). \n')
    else:
        # No NIC
        sys.stderr.write('WARN: No ethernet device (eth*) found! \n')
        sys.stderr.write('FAILED: All wired network settings unchanged. \n')
        return False
    
    
    
    return True
# end of setup_wired

############################################################
################ M A I N   R O U T L I N E  ################
############################################################

def main(argv):
    # System requirements check
    if not envreq():
        sys.stderr.write('ERROR: System requirements are not satisfied! \n')
        return 1
    
    # Load config file
    # `/boot/autoconfig.ini` for default,
    # but can also be customized via command line.
    if (len(sys.argv) < 2):
        configfile = loadconfig()
    else:
        configfile = loadconfig(sys.argv[1])
    
    if not configfile:
        sys.stderr.write('ERROR: autoconfig.ini file read error. \n')
        return 1
    
    # Config routline
    setup_screen(configfile)
    
    # Normal Exit
    return 0
# end of main()

if __name__ == '__main__': # Must be run standalone
    sys.exit(main(sys.argv))
